use rustc_hash::FxHashMap;

use crate::{Args, Backend, EmulatorState};

use self::{cranelift::CraneliftJitCache, rustc::RustcJitCache};

mod cranelift;
mod rustc;

/// Type for function generated by a JIT compiler.
///
/// Ideally we would want these to have this signature instead:
///
/// ```rust,ignore
/// type JitFunction = extern "C" fn(&mut EmulatorState) -> !;
/// ```
///
/// JIT functions would then simply always end with a tail call to another JIT
/// function. However this isn't possible since Rust doesn't support guaranteed
/// tail call optimization.
///
/// Instead we use a workaround where a JIT function returns a function pointer
/// to the next function that should be executed. The main loop in `run` below
/// repeatedly calls the next function as it is returned.
///
/// The function pointer is wrapped in a struct because it would otherwise be
/// impossible to write the type of a function pointer that returns itself.
#[repr(transparent)]
#[derive(Clone, Copy)]
pub(crate) struct JitFunction(pub extern "C" fn(&mut EmulatorState) -> JitFunction);

/// Set of already-compiled JIT functions.
///
/// JIT functions don't have an associated lifetime. They remain valid until the
/// unsafe `JitCache::flush` method is called.
pub(crate) struct JitCache {
    map: FxHashMap<u32, JitFunction>,

    /// Rustc JIT backend.
    rustc: RustcJitCache,

    /// Cranelift JIT backend.
    cranelift: CraneliftJitCache,
}

impl JitCache {
    /// Creates a new `JitCache`.
    pub(crate) fn new(args: &Args) -> Self {
        Self {
            map: FxHashMap::default(),
            rustc: RustcJitCache::new(args),
            cranelift: CraneliftJitCache::new(),
        }
    }

    /// Clears the JIT cache and releases all resources associated with
    /// previously compiled code.
    ///
    /// # Safety
    ///
    /// This function invalidates all `JitFunction`s previously returned by
    /// `compile`.
    pub(crate) unsafe fn flush(&mut self) {
        self.map.clear();
        self.rustc.flush();
    }
}

/// Default fallback JIT function which finds a JIT function to execute for
/// the current `state.pc`.
///
/// If no function is found then a new one is compiled.
///
/// Note that `state.pc` is not kept up-to-date by JIT code. It is only updated
/// when `lookup_or_translate` needs to be called.
pub(crate) extern "C" fn lookup_or_translate(state: &mut EmulatorState) -> JitFunction {
    *state
        .jit_cache
        .map
        .entry(state.pc)
        .or_insert_with(|| match state.args.backend {
            Backend::Interpreter => unreachable!(),
            Backend::JitRustc => state
                .jit_cache
                .rustc
                .compile(state.pc, &state.mem, &state.args),
            Backend::JitCranelift => {
                state
                    .jit_cache
                    .cranelift
                    .compile(state.pc, &state.mem, &state.args)
            }
        })
}

/// Main loop for JIT code.
///
/// As explained in the comments for `JitFunction`, we can't just jump into JIT
/// code and let it tail call to other JIT functions since Rust doesn't support
/// guaranteed tail calls. Instead the JIT functions return the address of the
/// next function to call and we just call that in a loop.
pub(crate) fn run(state: &mut EmulatorState) -> ! {
    let mut func = JitFunction(lookup_or_translate);
    loop {
        func = (func.0)(state);
    }
}
